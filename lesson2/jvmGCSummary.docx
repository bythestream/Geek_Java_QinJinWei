1.串行收集器（Serial Collector）

为单线程环境设计并且只使用一个线程进行垃圾回收，主要用于单线程环境（例如32位或Windows）和以及用于比较小的堆。会暂停所有的用户线程。所以不适合服务器环境,是java虛拟机运行在Client模式下默认的新生代垃圾收集器。

通过JVM参数-XX:+UseSerialGC可以使用串行垃圾回收器。

2.并行/吞吐量收集器（Parallel / Throughput collector）

多个垃圾回收线程并行工作，此时用户线程是暂停的，适用于科学计算/大数据处理等弱交互场景。 是JVM的默认收集器。最大的优点是使用多线程来扫描和压缩堆。在执行 minor或者 full 垃圾回收时将会STW。

3. CMS收集器（CMS Collector “并发标记扫描”）

用户线程和垃圾收集线程同时执行（不一定是并行，可能交替执行），不需要停顿用户线程。互联网公司多用它，适用于对响应时间有要求的场景。此算法使用多个线程（“并发”）扫描整个堆（“mark”），以查找可以回收的未使用对象（“sweep”）。该算法将在两种情况下进入“stop the world”（STW）模式：当初始化根（可以从线程入口点或静态变量访问的旧代中的对象）的初始标记时，以及当应用改变堆的状态的时候该收集器同时并发运行的时候，会强制cms再重新回去做一次执行来确保cms有正确的对象被标记。使用此收集器时最大的问题是遇到“推荐失败（promotion failures）”，就是在收集年轻和老年代之间发生竞争状况（race condition）的情况。如果收集器需要将young objects推荐到old generation，但没有足够的时间来清除它，这时候将导致FUll GC / STW . 为了避免这个情况，可以增加oldgen的大小（或把整个堆的大小变大）或给收集器分配更多的后台线程，以便能超过“对象分配的速度“。

与并行收集器相比，cms的另一个缺点是:使用更多的CPU，它通过使用多个线程执行扫描和收集，为应用程序提供更高水平的连续吞吐量。对于大多数长期运行的服务器应用程序，这种收集器不会让应用程序冻结，是一个合适的选择。此算法默认情况下不启用。需要指定XX：+ USeParNewGC来启用。如果能分配更多的CPU资源，以避免应用程序暂停，并且堆小于4GB，就适合使用CMS。如果堆大于4GB，那更适合下一个算法--G1收集器。

4. G1收集器

在JDK 7 update 4 中引入的“第一收集器”（G1），是专门为更好地支持大于4GB的堆而设计。 G1使用多个后台线程来扫描堆，将其划分为多个区域，范围从1MB到32MB（取决于堆的大小）。G1收集器先去扫描那些包含最多垃圾对象的区域，这种做法叫：Garbage first。此收集器使用-XX：+ UseG1GC打开。 

G1会出现STW的情况，就是在后台线程完成扫描未使用的对象之前堆被如果被耗尽的话，G1会停止应用程序而进入STW收集的状态。 G1另一个优点，就是它在执行的过程中可以顺便对堆进行压缩，这个能力CMS收集器只能在full STW收集期间才能做的。

最近的几年，大堆成了一个比较有争议的领域。越来越多的开发人员开始从单体化应用的那种一个机器一个JVM转移去开发更多的微服务，更多的基于模块的架构，这种情况下，每台机器上就会有多个JVM。
这是由许多因素驱动的，包括隔离应用程序的不同的部分，简化部署以及降低将应用程序的类reloading到内存中的成本等因素（在Java 8中实际已经又了许多改进）。即使如此，对JVM而言，最大的驱动因素之一就是希望避免那些长时间STW停顿（在对较大的堆中进行收集的时候，需要花很长时间）。 Docker等容器技术也加速了这一点，使您能够在相同的物理机器上轻松部署多个应用程序。

Java 8和G1收集器

另一个不错的改进就是Java 8 update 20的时候G1收集器开始支持字符串重复数据删除（String deduplication）。因为字符串（它们的内部是char []数组）占用了我们的大部分堆，所以进行了一个新的优化，使得G1收集器能够识别在整个堆中多次重复的字符串，并将它们纠正为指向同一个内部char[] 数组，以避免相同字符串的多个副本在堆内无效率地驻留。可以使用-XX：+ UseStringDeduplicationJVM参数来尝试此操作。

Java 8和PermGen

Java 8中最大的变化之一是删除了传统上为类元数据、内部字符串和静态变量分配的堆的permgen部分。在这之前，一般都要求开发人员来优化和tuning。这也是多年来成为许多OutOfMemory异常的源头，所以这个优化对我们帮助很大。即使如此，这也不会减少开发人员将他们的应用程序解耦到多个JVM的微服务的浪潮。

（https://cloud.tencent.com/developer/article/1083360）



